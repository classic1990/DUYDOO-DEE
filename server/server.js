const express = require('express');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '.env') });

const mongoose = require('mongoose');
const cors = require('cors');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');
const nodemailer = require('nodemailer');
const axios = require('axios');
const { GoogleGenerativeAI } = require("@google/generative-ai");
const rateLimit = require('express-rate-limit');

const app = express();

// --- 1. GLOBAL MIDDLEWARE ---
app.use(cors());
app.use(express.json());
// ‡∏™‡πà‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏≤‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå client (‡∏´‡∏ô‡πâ‡∏≤‡∏ö‡πâ‡∏≤‡∏ô) ‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ
app.use(express.static(path.join(__dirname, '../client')));
// Trust the first proxy, which is important for rate limiting to work correctly
// when the app is behind a reverse proxy (like Nginx or a cloud load balancer).
app.set('trust proxy', 1);

// --- 2. CONFIGURATIONS ---
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Nodemailer Transporter Configuration
const transporter = nodemailer.createTransport({
    host: process.env.EMAIL_HOST,
    port: process.env.EMAIL_PORT,
    secure: process.env.EMAIL_PORT == 465, // true for 465, false for other ports
    auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASS,
    },
});

// Rate Limiting Policies
const authLimiter = rateLimit({
	windowMs: 60 * 60 * 1000, // 1 hour
	max: 10, // Limit each IP to 10 login/register requests per window (per hour)
	message: { success: false, message: '‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏≤‡∏Å IP ‡∏ô‡∏µ‡πâ‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡∏≠‡∏µ‡∏Å 1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á' },
	standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
	legacyHeaders: false, // Disable the `X-RateLimit-*` headers
});

const apiLimiter = rateLimit({
	windowMs: 15 * 60 * 1000, // 15 minutes
	max: 100, // Limit each IP to 100 requests per window (per 15 minutes)
	message: { success: false, message: '‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô API ‡∏à‡∏≤‡∏Å IP ‡∏ô‡∏µ‡πâ‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡∏≠‡∏µ‡∏Å 15 ‡∏ô‡∏≤‡∏ó‡∏µ' },
	standardHeaders: true,
	legacyHeaders: false,
});

// --- 3. DATABASE CONNECTION ---
mongoose.connect(process.env.MONGO_URI)
    .then(() => {
        console.log(`‚úÖ MongoDB Connected to: ${mongoose.connection.name}`);
        // Seed admin user after connection
        seedAdminUser();
    })
    .catch(err => console.error('‚ùå MongoDB Connection Error:', err));

// --- 4. SCHEMAS & MODELS ---

const userSchema = new mongoose.Schema({
    username: { type: String, required: true, unique: true, trim: true, lowercase: true },
    password: { type: String, required: true },
    role: { type: String, enum: ['admin', 'vip', 'user'], default: 'user' },
    passwordResetToken: String,
    passwordResetExpires: Date,
});

// Middleware to hash password before saving
userSchema.pre('save', async function(next) {
    if (!this.isModified('password')) return next();
    try {
        const salt = await bcrypt.genSalt(10);
        this.password = await bcrypt.hash(this.password, salt);
        next();
    } catch (error) {
        next(error);
    }
});

// Method to compare password
userSchema.methods.comparePassword = function(candidatePassword) {
    return bcrypt.compare(candidatePassword, this.password);
};

// Method to generate password reset token
userSchema.methods.createPasswordResetToken = function() {
    const resetToken = crypto.randomBytes(32).toString('hex');

    this.passwordResetToken = crypto
        .createHash('sha256')
        .update(resetToken)
        .digest('hex');

    this.passwordResetExpires = Date.now() + 10 * 60 * 1000; // 10 minutes

    return resetToken;
};

const User = mongoose.model('User', userSchema);

const movieSchema = new mongoose.Schema({
    title: { type: String, required: true },
    year: { type: Number, default: 2026 },
    rating: { type: Number, default: 0.0 },
    description: String,
    actors: String,
    lessons: String,
    category: { type: String, default: 'china' },
    posterUrl: String,
    ytId: { type: String, required: true }, 
    totalEpisodes: { type: Number, default: 1 },
    isVip: { type: Boolean, default: false }, // ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ VIP
    episodes: [{
        epTitle: String,
        ytId: String
    }],
    createdAt: { type: Date, default: Date.now }
});

const commentSchema = new mongoose.Schema({
    movieId: { type: mongoose.Schema.Types.ObjectId, ref: 'Movie', required: true },
    username: { type: String, required: true },
    text: { type: String, required: true },
    createdAt: { type: Date, default: Date.now }
});

// ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≠‡∏•‡πÄ‡∏•‡∏Å‡∏ä‡∏±‡∏ô‡∏ä‡∏∑‡πà‡∏≠ 'series' ‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á
const Movie = mongoose.model('Movie', movieSchema, 'series'); 
const Comment = mongoose.model('Comment', commentSchema);

// --- 5. AUTHENTICATION MIDDLEWARE ---
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];
    if (!token) return res.status(401).json({ success: false, message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö' });

    jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
        if (err) return res.status(403).json({ success: false, message: '‡πÄ‡∏ã‡∏™‡∏ä‡∏±‡πà‡∏ô‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà' });
        req.user = user;
        next();
    });
};

const authorizeAdmin = (req, res, next) => {
    if (req.user && req.user.role === 'admin') return next();
    return res.status(403).json({ success: false, message: '‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÅ‡∏≠‡∏î‡∏°‡∏¥‡∏ô‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô' });
};

// --- 6. API ROUTER ---
const apiRouter = express.Router();

// [LOGIN] ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Admin ‡πÅ‡∏•‡∏∞ VIP
apiRouter.post('/login', authLimiter, async (req, res) => {
    try {
        const { username, password } = req.body;

        if (!username || !password) {
            return res.status(400).json({ success: false, message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡∏∞‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô' });
        }

        // 1. Find user in database
        const user = await User.findOne({ username: username.toLowerCase() });
        if (!user) {
            return res.status(401).json({ success: false, message: '‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á' });
        }

        // 2. Compare password
        const isMatch = await user.comparePassword(password);
        if (!isMatch) {
            return res.status(401).json({ success: false, message: '‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á' });
        }

        // 3. Create JWT
        const payload = {
            id: user._id,
            user: user.username,
            role: user.role
        };
        const expiresIn = user.role === 'admin' ? '1d' : '7d';
        const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn });

        return res.json({ success: true, accessToken: token, role: user.role });
    } catch (error) {
        console.error('Login Error:', error); // Log error ‡πÑ‡∏ß‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ô‡∏±‡∏Å‡∏û‡∏±‡∏í‡∏ô‡∏≤
        res.status(500).json({ success: false, message: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå' });
    }
});

// [REGISTER] ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ
apiRouter.post('/register', authLimiter, async (req, res) => {
    try {
        const { username, password } = req.body;

        if (!username || !password) {
            return res.status(400).json({ success: false, message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡∏∞‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô' });
        }
        if (password.length < 6) {
            return res.status(400).json({ success: false, message: '‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 6 ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£' });
        }

        const existingUser = await User.findOne({ username: username.toLowerCase() });
        if (existingUser) {
            return res.status(409).json({ success: false, message: '‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß' });
        }

        const newUser = new User({
            username: username,
            password: password, // Hashing is handled by the pre-save hook
        });

        await newUser.save();
        res.status(201).json({ success: true, message: '‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö' });
    } catch (error) {
        console.error('Register Error:', error);
        res.status(500).json({ success: false, message: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô' });
    }
});

// [FORGOT PASSWORD]
apiRouter.post('/forgot-password', async (req, res) => {
    try {
        // 1) Get user based on POSTed username
        const user = await User.findOne({ username: req.body.username });
        if (!user) {
            return res.status(404).json({ success: false, message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö' });
        }

        // 2) Generate the random reset token
        const resetToken = user.createPasswordResetToken();
        await user.save({ validateBeforeSave: false });

        // 3) Send it to user's email
        // Note: In a real app, user schema should have an email field. We use username as a placeholder.
        const resetURL = `${req.protocol}://${req.get('host')}/reset-password.html?token=${resetToken}`;

        const message = `
            ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏ô‡∏µ‡πâ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏Ñ‡∏∏‡∏ì (‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏Ñ‡∏£‡∏ö‡∏≤‡∏á‡∏Ñ‡∏ô) ‡πÑ‡∏î‡πâ‡∏£‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏Å‡∏≤‡∏£‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
            ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Ñ‡∏•‡∏¥‡∏Å‡∏•‡∏¥‡∏á‡∏Å‡πå‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏±‡πâ‡∏á‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÉ‡∏´‡∏°‡πà: ${resetURL}
            ‡∏•‡∏¥‡∏á‡∏Å‡πå‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÉ‡∏ô 10 ‡∏ô‡∏≤‡∏ó‡∏µ
            ‡∏´‡∏≤‡∏Å‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ú‡∏π‡πâ‡∏£‡πâ‡∏≠‡∏á‡∏Ç‡∏≠ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏û‡∏¥‡∏Å‡πÄ‡∏â‡∏¢‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏ô‡∏µ‡πâ
        `;

        await transporter.sendMail({
            from: `"DUYDODEE 4K Support" <${process.env.EMAIL_FROM}>`,
            to: req.body.username, // This should be user.email in a real app
            subject: '‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô (‡∏°‡∏µ‡∏ú‡∏• 10 ‡∏ô‡∏≤‡∏ó‡∏µ)',
            text: message,
        });

        res.status(200).json({ success: true, message: '‡∏•‡∏¥‡∏á‡∏Å‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏•‡πâ‡∏ß' });
    } catch (err) {
        // Invalidate token and expiry if something goes wrong
        if (user) {
            user.passwordResetToken = undefined;
            user.passwordResetExpires = undefined;
            await user.save({ validateBeforeSave: false });
        }
        console.error('FORGOT PASSWORD ERROR:', err);
        res.status(500).json({ success: false, message: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏≠‡∏µ‡πÄ‡∏°‡∏•' });
    }
});

// [RESET PASSWORD]
apiRouter.post('/reset-password/:token', async (req, res) => {
    try {
        // 1) Get user based on the token
        const hashedToken = crypto
            .createHash('sha256')
            .update(req.params.token)
            .digest('hex');

        const user = await User.findOne({
            passwordResetToken: hashedToken,
            passwordResetExpires: { $gt: Date.now() },
        });

        // 2) If token has not expired, and there is user, set the new password
        if (!user) {
            return res.status(400).json({ success: false, message: 'Token ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÅ‡∏•‡πâ‡∏ß' });
        }

        if (req.body.password.length < 6) {
            return res.status(400).json({ success: false, message: '‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 6 ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£' });
        }

        user.password = req.body.password;
        user.passwordResetToken = undefined;
        user.passwordResetExpires = undefined;
        await user.save();

        // 3) Log the user in, send JWT
        // (This part is optional, but good UX)
        res.status(200).json({ success: true, message: '‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏î‡πâ‡∏ß‡∏¢‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏î‡πâ‡πÅ‡∏•‡πâ‡∏ß' });
    } catch (err) {
        res.status(500).json({ success: false, message: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô' });
    }
});

// [AI FETCH] - ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡πâ‡∏ß‡∏¢ Gemini
apiRouter.post('/fetch-movie-data', authenticateToken, authorizeAdmin, async (req, res) => {
    try {
        const { videoId } = req.body;
        const ytUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoId}&key=${process.env.YOUTUBE_API_KEY}`;
        const ytRes = await axios.get(ytUrl);
        
        if (!ytRes.data.items?.length) return res.status(404).json({ success: false, message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠' });

        const snippet = ytRes.data.items[0].snippet;
        const model = genAI.getGenerativeModel({ 
            model: "gemini-1.5-flash",
            generationConfig: { responseMimeType: "application/json" }
        });
        const prompt = `‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏ô‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏ä‡∏∑‡πà‡∏≠ "${snippet.title}" ‡πÅ‡∏•‡∏∞‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤ "${snippet.description}" ‡∏ï‡∏≠‡∏ö‡πÄ‡∏õ‡πá‡∏ô JSON: { "title": "‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ó‡∏¢", "year": 2024, "rating": 9.0, "description": "‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏¢‡πà‡∏≠", "actors": "‡∏ä‡∏∑‡πà‡∏≠‡∏ô‡∏±‡∏Å‡πÅ‡∏™‡∏î‡∏á", "lessons": "‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏¥‡∏î" }`;

        const result = await model.generateContent(prompt);
        const aiData = JSON.parse(result.response.text());

        res.json({
            success: true,
            data: { ...aiData, posterUrl: `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`, ytId: videoId }
        });
    } catch (err) {
        res.status(500).json({ success: false, message: 'AI Error: ' + err.message });
    }
});

// [MOVIES CRUD]
apiRouter.get('/movies', async (req, res) => {
    try {
        const movies = await Movie.find().sort({ createdAt: -1 });
        res.json({ success: true, data: movies });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

apiRouter.post('/movies', authenticateToken, authorizeAdmin, async (req, res) => {
    try {
        const newMovie = new Movie(req.body);
        await newMovie.save();
        res.status(201).json({ success: true, data: newMovie });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

apiRouter.put('/movies/:id', authenticateToken, authorizeAdmin, async (req, res) => {
    try {
        const updated = await Movie.findByIdAndUpdate(req.params.id, req.body, { new: true });
        res.json({ success: true, data: updated });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

apiRouter.delete('/movies/:id', authenticateToken, authorizeAdmin, async (req, res) => {
    try {
        await Movie.findByIdAndDelete(req.params.id);
        res.json({ success: true, message: '‡∏•‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à' });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

// [COMMENTS]
apiRouter.get('/comments/:movieId', async (req, res) => {
    try {
        const comments = await Comment.find({ movieId: req.params.movieId }).sort({ createdAt: -1 });
        res.json({ success: true, data: comments });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

apiRouter.post('/comments', async (req, res) => {
    try {
        const newComment = new Comment(req.body);
        await newComment.save();
        res.status(201).json({ success: true, data: newComment });
    } catch (err) {
        res.status(500).json({ success: false, message: err.message });
    }
});

// Apply the general rate limiter to all requests to /api
app.use('/api', apiLimiter, apiRouter);

// --- Global Error Handler ---
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({ success: false, message: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå', error: err.message });
});

// --- Helper Functions ---
async function seedAdminUser() {
    try {
        const adminExists = await User.findOne({ role: 'admin' });
        if (!adminExists) {
            const adminUsername = process.env.ADMIN_USERNAME;
            const adminPassword = process.env.ADMIN_PASSWORD;

            if (!adminUsername || !adminPassword) {
                console.warn('‚ö†Ô∏è ADMIN_USERNAME or ADMIN_PASSWORD not set in .env. Cannot create admin user.');
                return;
            }

            const newAdmin = new User({
                username: adminUsername,
                password: adminPassword, // Password will be hashed by pre-save hook
                role: 'admin'
            });
            await newAdmin.save();
            console.log('‚úÖ Admin user created successfully.');
        }
    } catch (error) {
        console.error('‚ùå Error seeding admin user:', error);
    }
};
// --- 7. SPA FALLBACK ---
app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, '../client/index.html'));
});

// --- 8. START SERVER ---
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
    console.log(`üöÄ DUYDODEE 4K Server: http://localhost:${PORT}`);
});